// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package controllers

import (
	"database/sql"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"sync"
)

// DBerMock is a mock implementation of repositories.DBer.
//
//	func TestSomethingThatUsesDBer(t *testing.T) {
//
//		// make and configure a mocked repositories.DBer
//		mockedDBer := &DBerMock{
//			AssignFunc: func(attrs ...interface{}) *gorm.DB {
//				panic("mock out the Assign method")
//			},
//			AttrsFunc: func(attrs ...interface{}) *gorm.DB {
//				panic("mock out the Attrs method")
//			},
//			BeginFunc: func(opts ...*sql.TxOptions) *gorm.DB {
//				panic("mock out the Begin method")
//			},
//			ClausesFunc: func(conds ...clause.Expression) *gorm.DB {
//				panic("mock out the Clauses method")
//			},
//			CommitFunc: func() *gorm.DB {
//				panic("mock out the Commit method")
//			},
//			ConnectionFunc: func(fc func(tx *gorm.DB) error) error {
//				panic("mock out the Connection method")
//			},
//			CountFunc: func(count *int64) *gorm.DB {
//				panic("mock out the Count method")
//			},
//			CreateFunc: func(value interface{}) *gorm.DB {
//				panic("mock out the Create method")
//			},
//			CreateInBatchesFunc: func(value interface{}, batchSize int) *gorm.DB {
//				panic("mock out the CreateInBatches method")
//			},
//			DeleteFunc: func(value interface{}, conds ...interface{}) *gorm.DB {
//				panic("mock out the Delete method")
//			},
//			DistinctFunc: func(args ...interface{}) *gorm.DB {
//				panic("mock out the Distinct method")
//			},
//			ExecFunc: func(sqlMoqParam string, values ...interface{}) *gorm.DB {
//				panic("mock out the Exec method")
//			},
//			FindFunc: func(dest interface{}, conds ...interface{}) *gorm.DB {
//				panic("mock out the Find method")
//			},
//			FindInBatchesFunc: func(dest interface{}, batchSize int, fc func(tx *gorm.DB, batch int) error) *gorm.DB {
//				panic("mock out the FindInBatches method")
//			},
//			FirstFunc: func(dest interface{}, conds ...interface{}) *gorm.DB {
//				panic("mock out the First method")
//			},
//			FirstOrCreateFunc: func(dest interface{}, conds ...interface{}) *gorm.DB {
//				panic("mock out the FirstOrCreate method")
//			},
//			FirstOrInitFunc: func(dest interface{}, conds ...interface{}) *gorm.DB {
//				panic("mock out the FirstOrInit method")
//			},
//			GroupFunc: func(name string) *gorm.DB {
//				panic("mock out the Group method")
//			},
//			HavingFunc: func(query interface{}, args ...interface{}) *gorm.DB {
//				panic("mock out the Having method")
//			},
//			JoinsFunc: func(query string, args ...interface{}) *gorm.DB {
//				panic("mock out the Joins method")
//			},
//			LastFunc: func(dest interface{}, conds ...interface{}) *gorm.DB {
//				panic("mock out the Last method")
//			},
//			LimitFunc: func(limit int) *gorm.DB {
//				panic("mock out the Limit method")
//			},
//			ModelFunc: func(value interface{}) *gorm.DB {
//				panic("mock out the Model method")
//			},
//			NotFunc: func(query interface{}, args ...interface{}) *gorm.DB {
//				panic("mock out the Not method")
//			},
//			OffsetFunc: func(offset int) *gorm.DB {
//				panic("mock out the Offset method")
//			},
//			OmitFunc: func(columns ...string) *gorm.DB {
//				panic("mock out the Omit method")
//			},
//			OrFunc: func(query interface{}, args ...interface{}) *gorm.DB {
//				panic("mock out the Or method")
//			},
//			OrderFunc: func(value interface{}) *gorm.DB {
//				panic("mock out the Order method")
//			},
//			PluckFunc: func(column string, dest interface{}) *gorm.DB {
//				panic("mock out the Pluck method")
//			},
//			PreloadFunc: func(query string, args ...interface{}) *gorm.DB {
//				panic("mock out the Preload method")
//			},
//			RawFunc: func(sqlMoqParam string, values ...interface{}) *gorm.DB {
//				panic("mock out the Raw method")
//			},
//			RollbackFunc: func() *gorm.DB {
//				panic("mock out the Rollback method")
//			},
//			RollbackToFunc: func(name string) *gorm.DB {
//				panic("mock out the RollbackTo method")
//			},
//			RowFunc: func() *sql.Row {
//				panic("mock out the Row method")
//			},
//			RowsFunc: func() (*sql.Rows, error) {
//				panic("mock out the Rows method")
//			},
//			SaveFunc: func(value interface{}) *gorm.DB {
//				panic("mock out the Save method")
//			},
//			SavePointFunc: func(name string) *gorm.DB {
//				panic("mock out the SavePoint method")
//			},
//			ScanFunc: func(dest interface{}) *gorm.DB {
//				panic("mock out the Scan method")
//			},
//			ScanRowsFunc: func(rows *sql.Rows, dest interface{}) error {
//				panic("mock out the ScanRows method")
//			},
//			ScopesFunc: func(funcs ...func(*gorm.DB) *gorm.DB) *gorm.DB {
//				panic("mock out the Scopes method")
//			},
//			SelectFunc: func(query interface{}, args ...interface{}) *gorm.DB {
//				panic("mock out the Select method")
//			},
//			TableFunc: func(name string, args ...interface{}) *gorm.DB {
//				panic("mock out the Table method")
//			},
//			TakeFunc: func(dest interface{}, conds ...interface{}) *gorm.DB {
//				panic("mock out the Take method")
//			},
//			TransactionFunc: func(fc func(tx *gorm.DB) error, opts ...*sql.TxOptions) error {
//				panic("mock out the Transaction method")
//			},
//			UnscopedFunc: func() *gorm.DB {
//				panic("mock out the Unscoped method")
//			},
//			UpdateFunc: func(column string, value interface{}) *gorm.DB {
//				panic("mock out the Update method")
//			},
//			UpdateColumnFunc: func(column string, value interface{}) *gorm.DB {
//				panic("mock out the UpdateColumn method")
//			},
//			UpdateColumnsFunc: func(values interface{}) *gorm.DB {
//				panic("mock out the UpdateColumns method")
//			},
//			UpdatesFunc: func(values interface{}) *gorm.DB {
//				panic("mock out the Updates method")
//			},
//			WhereFunc: func(query interface{}, args ...interface{}) *gorm.DB {
//				panic("mock out the Where method")
//			},
//		}
//
//		// use mockedDBer in code that requires repositories.DBer
//		// and then make assertions.
//
//	}
type DBerMock struct {
	// AssignFunc mocks the Assign method.
	AssignFunc func(attrs ...interface{}) *gorm.DB

	// AttrsFunc mocks the Attrs method.
	AttrsFunc func(attrs ...interface{}) *gorm.DB

	// BeginFunc mocks the Begin method.
	BeginFunc func(opts ...*sql.TxOptions) *gorm.DB

	// ClausesFunc mocks the Clauses method.
	ClausesFunc func(conds ...clause.Expression) *gorm.DB

	// CommitFunc mocks the Commit method.
	CommitFunc func() *gorm.DB

	// ConnectionFunc mocks the Connection method.
	ConnectionFunc func(fc func(tx *gorm.DB) error) error

	// CountFunc mocks the Count method.
	CountFunc func(count *int64) *gorm.DB

	// CreateFunc mocks the Create method.
	CreateFunc func(value interface{}) *gorm.DB

	// CreateInBatchesFunc mocks the CreateInBatches method.
	CreateInBatchesFunc func(value interface{}, batchSize int) *gorm.DB

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(value interface{}, conds ...interface{}) *gorm.DB

	// DistinctFunc mocks the Distinct method.
	DistinctFunc func(args ...interface{}) *gorm.DB

	// ExecFunc mocks the Exec method.
	ExecFunc func(sqlMoqParam string, values ...interface{}) *gorm.DB

	// FindFunc mocks the Find method.
	FindFunc func(dest interface{}, conds ...interface{}) *gorm.DB

	// FindInBatchesFunc mocks the FindInBatches method.
	FindInBatchesFunc func(dest interface{}, batchSize int, fc func(tx *gorm.DB, batch int) error) *gorm.DB

	// FirstFunc mocks the First method.
	FirstFunc func(dest interface{}, conds ...interface{}) *gorm.DB

	// FirstOrCreateFunc mocks the FirstOrCreate method.
	FirstOrCreateFunc func(dest interface{}, conds ...interface{}) *gorm.DB

	// FirstOrInitFunc mocks the FirstOrInit method.
	FirstOrInitFunc func(dest interface{}, conds ...interface{}) *gorm.DB

	// GroupFunc mocks the Group method.
	GroupFunc func(name string) *gorm.DB

	// HavingFunc mocks the Having method.
	HavingFunc func(query interface{}, args ...interface{}) *gorm.DB

	// JoinsFunc mocks the Joins method.
	JoinsFunc func(query string, args ...interface{}) *gorm.DB

	// LastFunc mocks the Last method.
	LastFunc func(dest interface{}, conds ...interface{}) *gorm.DB

	// LimitFunc mocks the Limit method.
	LimitFunc func(limit int) *gorm.DB

	// ModelFunc mocks the Model method.
	ModelFunc func(value interface{}) *gorm.DB

	// NotFunc mocks the Not method.
	NotFunc func(query interface{}, args ...interface{}) *gorm.DB

	// OffsetFunc mocks the Offset method.
	OffsetFunc func(offset int) *gorm.DB

	// OmitFunc mocks the Omit method.
	OmitFunc func(columns ...string) *gorm.DB

	// OrFunc mocks the Or method.
	OrFunc func(query interface{}, args ...interface{}) *gorm.DB

	// OrderFunc mocks the Order method.
	OrderFunc func(value interface{}) *gorm.DB

	// PluckFunc mocks the Pluck method.
	PluckFunc func(column string, dest interface{}) *gorm.DB

	// PreloadFunc mocks the Preload method.
	PreloadFunc func(query string, args ...interface{}) *gorm.DB

	// RawFunc mocks the Raw method.
	RawFunc func(sqlMoqParam string, values ...interface{}) *gorm.DB

	// RollbackFunc mocks the Rollback method.
	RollbackFunc func() *gorm.DB

	// RollbackToFunc mocks the RollbackTo method.
	RollbackToFunc func(name string) *gorm.DB

	// RowFunc mocks the Row method.
	RowFunc func() *sql.Row

	// RowsFunc mocks the Rows method.
	RowsFunc func() (*sql.Rows, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(value interface{}) *gorm.DB

	// SavePointFunc mocks the SavePoint method.
	SavePointFunc func(name string) *gorm.DB

	// ScanFunc mocks the Scan method.
	ScanFunc func(dest interface{}) *gorm.DB

	// ScanRowsFunc mocks the ScanRows method.
	ScanRowsFunc func(rows *sql.Rows, dest interface{}) error

	// ScopesFunc mocks the Scopes method.
	ScopesFunc func(funcs ...func(*gorm.DB) *gorm.DB) *gorm.DB

	// SelectFunc mocks the Select method.
	SelectFunc func(query interface{}, args ...interface{}) *gorm.DB

	// TableFunc mocks the Table method.
	TableFunc func(name string, args ...interface{}) *gorm.DB

	// TakeFunc mocks the Take method.
	TakeFunc func(dest interface{}, conds ...interface{}) *gorm.DB

	// TransactionFunc mocks the Transaction method.
	TransactionFunc func(fc func(tx *gorm.DB) error, opts ...*sql.TxOptions) error

	// UnscopedFunc mocks the Unscoped method.
	UnscopedFunc func() *gorm.DB

	// UpdateFunc mocks the Update method.
	UpdateFunc func(column string, value interface{}) *gorm.DB

	// UpdateColumnFunc mocks the UpdateColumn method.
	UpdateColumnFunc func(column string, value interface{}) *gorm.DB

	// UpdateColumnsFunc mocks the UpdateColumns method.
	UpdateColumnsFunc func(values interface{}) *gorm.DB

	// UpdatesFunc mocks the Updates method.
	UpdatesFunc func(values interface{}) *gorm.DB

	// WhereFunc mocks the Where method.
	WhereFunc func(query interface{}, args ...interface{}) *gorm.DB

	// calls tracks calls to the methods.
	calls struct {
		// Assign holds details about calls to the Assign method.
		Assign []struct {
			// Attrs is the attrs argument value.
			Attrs []interface{}
		}
		// Attrs holds details about calls to the Attrs method.
		Attrs []struct {
			// Attrs is the attrs argument value.
			Attrs []interface{}
		}
		// Begin holds details about calls to the Begin method.
		Begin []struct {
			// Opts is the opts argument value.
			Opts []*sql.TxOptions
		}
		// Clauses holds details about calls to the Clauses method.
		Clauses []struct {
			// Conds is the conds argument value.
			Conds []clause.Expression
		}
		// Commit holds details about calls to the Commit method.
		Commit []struct {
		}
		// Connection holds details about calls to the Connection method.
		Connection []struct {
			// Fc is the fc argument value.
			Fc func(tx *gorm.DB) error
		}
		// Count holds details about calls to the Count method.
		Count []struct {
			// Count is the count argument value.
			Count *int64
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Value is the value argument value.
			Value interface{}
		}
		// CreateInBatches holds details about calls to the CreateInBatches method.
		CreateInBatches []struct {
			// Value is the value argument value.
			Value interface{}
			// BatchSize is the batchSize argument value.
			BatchSize int
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Value is the value argument value.
			Value interface{}
			// Conds is the conds argument value.
			Conds []interface{}
		}
		// Distinct holds details about calls to the Distinct method.
		Distinct []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// SqlMoqParam is the sqlMoqParam argument value.
			SqlMoqParam string
			// Values is the values argument value.
			Values []interface{}
		}
		// Find holds details about calls to the Find method.
		Find []struct {
			// Dest is the dest argument value.
			Dest interface{}
			// Conds is the conds argument value.
			Conds []interface{}
		}
		// FindInBatches holds details about calls to the FindInBatches method.
		FindInBatches []struct {
			// Dest is the dest argument value.
			Dest interface{}
			// BatchSize is the batchSize argument value.
			BatchSize int
			// Fc is the fc argument value.
			Fc func(tx *gorm.DB, batch int) error
		}
		// First holds details about calls to the First method.
		First []struct {
			// Dest is the dest argument value.
			Dest interface{}
			// Conds is the conds argument value.
			Conds []interface{}
		}
		// FirstOrCreate holds details about calls to the FirstOrCreate method.
		FirstOrCreate []struct {
			// Dest is the dest argument value.
			Dest interface{}
			// Conds is the conds argument value.
			Conds []interface{}
		}
		// FirstOrInit holds details about calls to the FirstOrInit method.
		FirstOrInit []struct {
			// Dest is the dest argument value.
			Dest interface{}
			// Conds is the conds argument value.
			Conds []interface{}
		}
		// Group holds details about calls to the Group method.
		Group []struct {
			// Name is the name argument value.
			Name string
		}
		// Having holds details about calls to the Having method.
		Having []struct {
			// Query is the query argument value.
			Query interface{}
			// Args is the args argument value.
			Args []interface{}
		}
		// Joins holds details about calls to the Joins method.
		Joins []struct {
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
		// Last holds details about calls to the Last method.
		Last []struct {
			// Dest is the dest argument value.
			Dest interface{}
			// Conds is the conds argument value.
			Conds []interface{}
		}
		// Limit holds details about calls to the Limit method.
		Limit []struct {
			// Limit is the limit argument value.
			Limit int
		}
		// Model holds details about calls to the Model method.
		Model []struct {
			// Value is the value argument value.
			Value interface{}
		}
		// Not holds details about calls to the Not method.
		Not []struct {
			// Query is the query argument value.
			Query interface{}
			// Args is the args argument value.
			Args []interface{}
		}
		// Offset holds details about calls to the Offset method.
		Offset []struct {
			// Offset is the offset argument value.
			Offset int
		}
		// Omit holds details about calls to the Omit method.
		Omit []struct {
			// Columns is the columns argument value.
			Columns []string
		}
		// Or holds details about calls to the Or method.
		Or []struct {
			// Query is the query argument value.
			Query interface{}
			// Args is the args argument value.
			Args []interface{}
		}
		// Order holds details about calls to the Order method.
		Order []struct {
			// Value is the value argument value.
			Value interface{}
		}
		// Pluck holds details about calls to the Pluck method.
		Pluck []struct {
			// Column is the column argument value.
			Column string
			// Dest is the dest argument value.
			Dest interface{}
		}
		// Preload holds details about calls to the Preload method.
		Preload []struct {
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
		// Raw holds details about calls to the Raw method.
		Raw []struct {
			// SqlMoqParam is the sqlMoqParam argument value.
			SqlMoqParam string
			// Values is the values argument value.
			Values []interface{}
		}
		// Rollback holds details about calls to the Rollback method.
		Rollback []struct {
		}
		// RollbackTo holds details about calls to the RollbackTo method.
		RollbackTo []struct {
			// Name is the name argument value.
			Name string
		}
		// Row holds details about calls to the Row method.
		Row []struct {
		}
		// Rows holds details about calls to the Rows method.
		Rows []struct {
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Value is the value argument value.
			Value interface{}
		}
		// SavePoint holds details about calls to the SavePoint method.
		SavePoint []struct {
			// Name is the name argument value.
			Name string
		}
		// Scan holds details about calls to the Scan method.
		Scan []struct {
			// Dest is the dest argument value.
			Dest interface{}
		}
		// ScanRows holds details about calls to the ScanRows method.
		ScanRows []struct {
			// Rows is the rows argument value.
			Rows *sql.Rows
			// Dest is the dest argument value.
			Dest interface{}
		}
		// Scopes holds details about calls to the Scopes method.
		Scopes []struct {
			// Funcs is the funcs argument value.
			Funcs []func(*gorm.DB) *gorm.DB
		}
		// Select holds details about calls to the Select method.
		Select []struct {
			// Query is the query argument value.
			Query interface{}
			// Args is the args argument value.
			Args []interface{}
		}
		// Table holds details about calls to the Table method.
		Table []struct {
			// Name is the name argument value.
			Name string
			// Args is the args argument value.
			Args []interface{}
		}
		// Take holds details about calls to the Take method.
		Take []struct {
			// Dest is the dest argument value.
			Dest interface{}
			// Conds is the conds argument value.
			Conds []interface{}
		}
		// Transaction holds details about calls to the Transaction method.
		Transaction []struct {
			// Fc is the fc argument value.
			Fc func(tx *gorm.DB) error
			// Opts is the opts argument value.
			Opts []*sql.TxOptions
		}
		// Unscoped holds details about calls to the Unscoped method.
		Unscoped []struct {
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Column is the column argument value.
			Column string
			// Value is the value argument value.
			Value interface{}
		}
		// UpdateColumn holds details about calls to the UpdateColumn method.
		UpdateColumn []struct {
			// Column is the column argument value.
			Column string
			// Value is the value argument value.
			Value interface{}
		}
		// UpdateColumns holds details about calls to the UpdateColumns method.
		UpdateColumns []struct {
			// Values is the values argument value.
			Values interface{}
		}
		// Updates holds details about calls to the Updates method.
		Updates []struct {
			// Values is the values argument value.
			Values interface{}
		}
		// Where holds details about calls to the Where method.
		Where []struct {
			// Query is the query argument value.
			Query interface{}
			// Args is the args argument value.
			Args []interface{}
		}
	}
	lockAssign          sync.RWMutex
	lockAttrs           sync.RWMutex
	lockBegin           sync.RWMutex
	lockClauses         sync.RWMutex
	lockCommit          sync.RWMutex
	lockConnection      sync.RWMutex
	lockCount           sync.RWMutex
	lockCreate          sync.RWMutex
	lockCreateInBatches sync.RWMutex
	lockDelete          sync.RWMutex
	lockDistinct        sync.RWMutex
	lockExec            sync.RWMutex
	lockFind            sync.RWMutex
	lockFindInBatches   sync.RWMutex
	lockFirst           sync.RWMutex
	lockFirstOrCreate   sync.RWMutex
	lockFirstOrInit     sync.RWMutex
	lockGroup           sync.RWMutex
	lockHaving          sync.RWMutex
	lockJoins           sync.RWMutex
	lockLast            sync.RWMutex
	lockLimit           sync.RWMutex
	lockModel           sync.RWMutex
	lockNot             sync.RWMutex
	lockOffset          sync.RWMutex
	lockOmit            sync.RWMutex
	lockOr              sync.RWMutex
	lockOrder           sync.RWMutex
	lockPluck           sync.RWMutex
	lockPreload         sync.RWMutex
	lockRaw             sync.RWMutex
	lockRollback        sync.RWMutex
	lockRollbackTo      sync.RWMutex
	lockRow             sync.RWMutex
	lockRows            sync.RWMutex
	lockSave            sync.RWMutex
	lockSavePoint       sync.RWMutex
	lockScan            sync.RWMutex
	lockScanRows        sync.RWMutex
	lockScopes          sync.RWMutex
	lockSelect          sync.RWMutex
	lockTable           sync.RWMutex
	lockTake            sync.RWMutex
	lockTransaction     sync.RWMutex
	lockUnscoped        sync.RWMutex
	lockUpdate          sync.RWMutex
	lockUpdateColumn    sync.RWMutex
	lockUpdateColumns   sync.RWMutex
	lockUpdates         sync.RWMutex
	lockWhere           sync.RWMutex
}

// Assign calls AssignFunc.
func (mock *DBerMock) Assign(attrs ...interface{}) *gorm.DB {
	if mock.AssignFunc == nil {
		panic("DBerMock.AssignFunc: method is nil but DBer.Assign was just called")
	}
	callInfo := struct {
		Attrs []interface{}
	}{
		Attrs: attrs,
	}
	mock.lockAssign.Lock()
	mock.calls.Assign = append(mock.calls.Assign, callInfo)
	mock.lockAssign.Unlock()
	return mock.AssignFunc(attrs...)
}

// AssignCalls gets all the calls that were made to Assign.
// Check the length with:
//
//	len(mockedDBer.AssignCalls())
func (mock *DBerMock) AssignCalls() []struct {
	Attrs []interface{}
} {
	var calls []struct {
		Attrs []interface{}
	}
	mock.lockAssign.RLock()
	calls = mock.calls.Assign
	mock.lockAssign.RUnlock()
	return calls
}

// Attrs calls AttrsFunc.
func (mock *DBerMock) Attrs(attrs ...interface{}) *gorm.DB {
	if mock.AttrsFunc == nil {
		panic("DBerMock.AttrsFunc: method is nil but DBer.Attrs was just called")
	}
	callInfo := struct {
		Attrs []interface{}
	}{
		Attrs: attrs,
	}
	mock.lockAttrs.Lock()
	mock.calls.Attrs = append(mock.calls.Attrs, callInfo)
	mock.lockAttrs.Unlock()
	return mock.AttrsFunc(attrs...)
}

// AttrsCalls gets all the calls that were made to Attrs.
// Check the length with:
//
//	len(mockedDBer.AttrsCalls())
func (mock *DBerMock) AttrsCalls() []struct {
	Attrs []interface{}
} {
	var calls []struct {
		Attrs []interface{}
	}
	mock.lockAttrs.RLock()
	calls = mock.calls.Attrs
	mock.lockAttrs.RUnlock()
	return calls
}

// Begin calls BeginFunc.
func (mock *DBerMock) Begin(opts ...*sql.TxOptions) *gorm.DB {
	if mock.BeginFunc == nil {
		panic("DBerMock.BeginFunc: method is nil but DBer.Begin was just called")
	}
	callInfo := struct {
		Opts []*sql.TxOptions
	}{
		Opts: opts,
	}
	mock.lockBegin.Lock()
	mock.calls.Begin = append(mock.calls.Begin, callInfo)
	mock.lockBegin.Unlock()
	return mock.BeginFunc(opts...)
}

// BeginCalls gets all the calls that were made to Begin.
// Check the length with:
//
//	len(mockedDBer.BeginCalls())
func (mock *DBerMock) BeginCalls() []struct {
	Opts []*sql.TxOptions
} {
	var calls []struct {
		Opts []*sql.TxOptions
	}
	mock.lockBegin.RLock()
	calls = mock.calls.Begin
	mock.lockBegin.RUnlock()
	return calls
}

// Clauses calls ClausesFunc.
func (mock *DBerMock) Clauses(conds ...clause.Expression) *gorm.DB {
	if mock.ClausesFunc == nil {
		panic("DBerMock.ClausesFunc: method is nil but DBer.Clauses was just called")
	}
	callInfo := struct {
		Conds []clause.Expression
	}{
		Conds: conds,
	}
	mock.lockClauses.Lock()
	mock.calls.Clauses = append(mock.calls.Clauses, callInfo)
	mock.lockClauses.Unlock()
	return mock.ClausesFunc(conds...)
}

// ClausesCalls gets all the calls that were made to Clauses.
// Check the length with:
//
//	len(mockedDBer.ClausesCalls())
func (mock *DBerMock) ClausesCalls() []struct {
	Conds []clause.Expression
} {
	var calls []struct {
		Conds []clause.Expression
	}
	mock.lockClauses.RLock()
	calls = mock.calls.Clauses
	mock.lockClauses.RUnlock()
	return calls
}

// Commit calls CommitFunc.
func (mock *DBerMock) Commit() *gorm.DB {
	if mock.CommitFunc == nil {
		panic("DBerMock.CommitFunc: method is nil but DBer.Commit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	return mock.CommitFunc()
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//
//	len(mockedDBer.CommitCalls())
func (mock *DBerMock) CommitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// Connection calls ConnectionFunc.
func (mock *DBerMock) Connection(fc func(tx *gorm.DB) error) error {
	if mock.ConnectionFunc == nil {
		panic("DBerMock.ConnectionFunc: method is nil but DBer.Connection was just called")
	}
	callInfo := struct {
		Fc func(tx *gorm.DB) error
	}{
		Fc: fc,
	}
	mock.lockConnection.Lock()
	mock.calls.Connection = append(mock.calls.Connection, callInfo)
	mock.lockConnection.Unlock()
	return mock.ConnectionFunc(fc)
}

// ConnectionCalls gets all the calls that were made to Connection.
// Check the length with:
//
//	len(mockedDBer.ConnectionCalls())
func (mock *DBerMock) ConnectionCalls() []struct {
	Fc func(tx *gorm.DB) error
} {
	var calls []struct {
		Fc func(tx *gorm.DB) error
	}
	mock.lockConnection.RLock()
	calls = mock.calls.Connection
	mock.lockConnection.RUnlock()
	return calls
}

// Count calls CountFunc.
func (mock *DBerMock) Count(count *int64) *gorm.DB {
	if mock.CountFunc == nil {
		panic("DBerMock.CountFunc: method is nil but DBer.Count was just called")
	}
	callInfo := struct {
		Count *int64
	}{
		Count: count,
	}
	mock.lockCount.Lock()
	mock.calls.Count = append(mock.calls.Count, callInfo)
	mock.lockCount.Unlock()
	return mock.CountFunc(count)
}

// CountCalls gets all the calls that were made to Count.
// Check the length with:
//
//	len(mockedDBer.CountCalls())
func (mock *DBerMock) CountCalls() []struct {
	Count *int64
} {
	var calls []struct {
		Count *int64
	}
	mock.lockCount.RLock()
	calls = mock.calls.Count
	mock.lockCount.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *DBerMock) Create(value interface{}) *gorm.DB {
	if mock.CreateFunc == nil {
		panic("DBerMock.CreateFunc: method is nil but DBer.Create was just called")
	}
	callInfo := struct {
		Value interface{}
	}{
		Value: value,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(value)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedDBer.CreateCalls())
func (mock *DBerMock) CreateCalls() []struct {
	Value interface{}
} {
	var calls []struct {
		Value interface{}
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// CreateInBatches calls CreateInBatchesFunc.
func (mock *DBerMock) CreateInBatches(value interface{}, batchSize int) *gorm.DB {
	if mock.CreateInBatchesFunc == nil {
		panic("DBerMock.CreateInBatchesFunc: method is nil but DBer.CreateInBatches was just called")
	}
	callInfo := struct {
		Value     interface{}
		BatchSize int
	}{
		Value:     value,
		BatchSize: batchSize,
	}
	mock.lockCreateInBatches.Lock()
	mock.calls.CreateInBatches = append(mock.calls.CreateInBatches, callInfo)
	mock.lockCreateInBatches.Unlock()
	return mock.CreateInBatchesFunc(value, batchSize)
}

// CreateInBatchesCalls gets all the calls that were made to CreateInBatches.
// Check the length with:
//
//	len(mockedDBer.CreateInBatchesCalls())
func (mock *DBerMock) CreateInBatchesCalls() []struct {
	Value     interface{}
	BatchSize int
} {
	var calls []struct {
		Value     interface{}
		BatchSize int
	}
	mock.lockCreateInBatches.RLock()
	calls = mock.calls.CreateInBatches
	mock.lockCreateInBatches.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *DBerMock) Delete(value interface{}, conds ...interface{}) *gorm.DB {
	if mock.DeleteFunc == nil {
		panic("DBerMock.DeleteFunc: method is nil but DBer.Delete was just called")
	}
	callInfo := struct {
		Value interface{}
		Conds []interface{}
	}{
		Value: value,
		Conds: conds,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(value, conds...)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedDBer.DeleteCalls())
func (mock *DBerMock) DeleteCalls() []struct {
	Value interface{}
	Conds []interface{}
} {
	var calls []struct {
		Value interface{}
		Conds []interface{}
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Distinct calls DistinctFunc.
func (mock *DBerMock) Distinct(args ...interface{}) *gorm.DB {
	if mock.DistinctFunc == nil {
		panic("DBerMock.DistinctFunc: method is nil but DBer.Distinct was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockDistinct.Lock()
	mock.calls.Distinct = append(mock.calls.Distinct, callInfo)
	mock.lockDistinct.Unlock()
	return mock.DistinctFunc(args...)
}

// DistinctCalls gets all the calls that were made to Distinct.
// Check the length with:
//
//	len(mockedDBer.DistinctCalls())
func (mock *DBerMock) DistinctCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockDistinct.RLock()
	calls = mock.calls.Distinct
	mock.lockDistinct.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *DBerMock) Exec(sqlMoqParam string, values ...interface{}) *gorm.DB {
	if mock.ExecFunc == nil {
		panic("DBerMock.ExecFunc: method is nil but DBer.Exec was just called")
	}
	callInfo := struct {
		SqlMoqParam string
		Values      []interface{}
	}{
		SqlMoqParam: sqlMoqParam,
		Values:      values,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(sqlMoqParam, values...)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedDBer.ExecCalls())
func (mock *DBerMock) ExecCalls() []struct {
	SqlMoqParam string
	Values      []interface{}
} {
	var calls []struct {
		SqlMoqParam string
		Values      []interface{}
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// Find calls FindFunc.
func (mock *DBerMock) Find(dest interface{}, conds ...interface{}) *gorm.DB {
	if mock.FindFunc == nil {
		panic("DBerMock.FindFunc: method is nil but DBer.Find was just called")
	}
	callInfo := struct {
		Dest  interface{}
		Conds []interface{}
	}{
		Dest:  dest,
		Conds: conds,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(dest, conds...)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedDBer.FindCalls())
func (mock *DBerMock) FindCalls() []struct {
	Dest  interface{}
	Conds []interface{}
} {
	var calls []struct {
		Dest  interface{}
		Conds []interface{}
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// FindInBatches calls FindInBatchesFunc.
func (mock *DBerMock) FindInBatches(dest interface{}, batchSize int, fc func(tx *gorm.DB, batch int) error) *gorm.DB {
	if mock.FindInBatchesFunc == nil {
		panic("DBerMock.FindInBatchesFunc: method is nil but DBer.FindInBatches was just called")
	}
	callInfo := struct {
		Dest      interface{}
		BatchSize int
		Fc        func(tx *gorm.DB, batch int) error
	}{
		Dest:      dest,
		BatchSize: batchSize,
		Fc:        fc,
	}
	mock.lockFindInBatches.Lock()
	mock.calls.FindInBatches = append(mock.calls.FindInBatches, callInfo)
	mock.lockFindInBatches.Unlock()
	return mock.FindInBatchesFunc(dest, batchSize, fc)
}

// FindInBatchesCalls gets all the calls that were made to FindInBatches.
// Check the length with:
//
//	len(mockedDBer.FindInBatchesCalls())
func (mock *DBerMock) FindInBatchesCalls() []struct {
	Dest      interface{}
	BatchSize int
	Fc        func(tx *gorm.DB, batch int) error
} {
	var calls []struct {
		Dest      interface{}
		BatchSize int
		Fc        func(tx *gorm.DB, batch int) error
	}
	mock.lockFindInBatches.RLock()
	calls = mock.calls.FindInBatches
	mock.lockFindInBatches.RUnlock()
	return calls
}

// First calls FirstFunc.
func (mock *DBerMock) First(dest interface{}, conds ...interface{}) *gorm.DB {
	if mock.FirstFunc == nil {
		panic("DBerMock.FirstFunc: method is nil but DBer.First was just called")
	}
	callInfo := struct {
		Dest  interface{}
		Conds []interface{}
	}{
		Dest:  dest,
		Conds: conds,
	}
	mock.lockFirst.Lock()
	mock.calls.First = append(mock.calls.First, callInfo)
	mock.lockFirst.Unlock()
	return mock.FirstFunc(dest, conds...)
}

// FirstCalls gets all the calls that were made to First.
// Check the length with:
//
//	len(mockedDBer.FirstCalls())
func (mock *DBerMock) FirstCalls() []struct {
	Dest  interface{}
	Conds []interface{}
} {
	var calls []struct {
		Dest  interface{}
		Conds []interface{}
	}
	mock.lockFirst.RLock()
	calls = mock.calls.First
	mock.lockFirst.RUnlock()
	return calls
}

// FirstOrCreate calls FirstOrCreateFunc.
func (mock *DBerMock) FirstOrCreate(dest interface{}, conds ...interface{}) *gorm.DB {
	if mock.FirstOrCreateFunc == nil {
		panic("DBerMock.FirstOrCreateFunc: method is nil but DBer.FirstOrCreate was just called")
	}
	callInfo := struct {
		Dest  interface{}
		Conds []interface{}
	}{
		Dest:  dest,
		Conds: conds,
	}
	mock.lockFirstOrCreate.Lock()
	mock.calls.FirstOrCreate = append(mock.calls.FirstOrCreate, callInfo)
	mock.lockFirstOrCreate.Unlock()
	return mock.FirstOrCreateFunc(dest, conds...)
}

// FirstOrCreateCalls gets all the calls that were made to FirstOrCreate.
// Check the length with:
//
//	len(mockedDBer.FirstOrCreateCalls())
func (mock *DBerMock) FirstOrCreateCalls() []struct {
	Dest  interface{}
	Conds []interface{}
} {
	var calls []struct {
		Dest  interface{}
		Conds []interface{}
	}
	mock.lockFirstOrCreate.RLock()
	calls = mock.calls.FirstOrCreate
	mock.lockFirstOrCreate.RUnlock()
	return calls
}

// FirstOrInit calls FirstOrInitFunc.
func (mock *DBerMock) FirstOrInit(dest interface{}, conds ...interface{}) *gorm.DB {
	if mock.FirstOrInitFunc == nil {
		panic("DBerMock.FirstOrInitFunc: method is nil but DBer.FirstOrInit was just called")
	}
	callInfo := struct {
		Dest  interface{}
		Conds []interface{}
	}{
		Dest:  dest,
		Conds: conds,
	}
	mock.lockFirstOrInit.Lock()
	mock.calls.FirstOrInit = append(mock.calls.FirstOrInit, callInfo)
	mock.lockFirstOrInit.Unlock()
	return mock.FirstOrInitFunc(dest, conds...)
}

// FirstOrInitCalls gets all the calls that were made to FirstOrInit.
// Check the length with:
//
//	len(mockedDBer.FirstOrInitCalls())
func (mock *DBerMock) FirstOrInitCalls() []struct {
	Dest  interface{}
	Conds []interface{}
} {
	var calls []struct {
		Dest  interface{}
		Conds []interface{}
	}
	mock.lockFirstOrInit.RLock()
	calls = mock.calls.FirstOrInit
	mock.lockFirstOrInit.RUnlock()
	return calls
}

// Group calls GroupFunc.
func (mock *DBerMock) Group(name string) *gorm.DB {
	if mock.GroupFunc == nil {
		panic("DBerMock.GroupFunc: method is nil but DBer.Group was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockGroup.Lock()
	mock.calls.Group = append(mock.calls.Group, callInfo)
	mock.lockGroup.Unlock()
	return mock.GroupFunc(name)
}

// GroupCalls gets all the calls that were made to Group.
// Check the length with:
//
//	len(mockedDBer.GroupCalls())
func (mock *DBerMock) GroupCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockGroup.RLock()
	calls = mock.calls.Group
	mock.lockGroup.RUnlock()
	return calls
}

// Having calls HavingFunc.
func (mock *DBerMock) Having(query interface{}, args ...interface{}) *gorm.DB {
	if mock.HavingFunc == nil {
		panic("DBerMock.HavingFunc: method is nil but DBer.Having was just called")
	}
	callInfo := struct {
		Query interface{}
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	mock.lockHaving.Lock()
	mock.calls.Having = append(mock.calls.Having, callInfo)
	mock.lockHaving.Unlock()
	return mock.HavingFunc(query, args...)
}

// HavingCalls gets all the calls that were made to Having.
// Check the length with:
//
//	len(mockedDBer.HavingCalls())
func (mock *DBerMock) HavingCalls() []struct {
	Query interface{}
	Args  []interface{}
} {
	var calls []struct {
		Query interface{}
		Args  []interface{}
	}
	mock.lockHaving.RLock()
	calls = mock.calls.Having
	mock.lockHaving.RUnlock()
	return calls
}

// Joins calls JoinsFunc.
func (mock *DBerMock) Joins(query string, args ...interface{}) *gorm.DB {
	if mock.JoinsFunc == nil {
		panic("DBerMock.JoinsFunc: method is nil but DBer.Joins was just called")
	}
	callInfo := struct {
		Query string
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	mock.lockJoins.Lock()
	mock.calls.Joins = append(mock.calls.Joins, callInfo)
	mock.lockJoins.Unlock()
	return mock.JoinsFunc(query, args...)
}

// JoinsCalls gets all the calls that were made to Joins.
// Check the length with:
//
//	len(mockedDBer.JoinsCalls())
func (mock *DBerMock) JoinsCalls() []struct {
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Query string
		Args  []interface{}
	}
	mock.lockJoins.RLock()
	calls = mock.calls.Joins
	mock.lockJoins.RUnlock()
	return calls
}

// Last calls LastFunc.
func (mock *DBerMock) Last(dest interface{}, conds ...interface{}) *gorm.DB {
	if mock.LastFunc == nil {
		panic("DBerMock.LastFunc: method is nil but DBer.Last was just called")
	}
	callInfo := struct {
		Dest  interface{}
		Conds []interface{}
	}{
		Dest:  dest,
		Conds: conds,
	}
	mock.lockLast.Lock()
	mock.calls.Last = append(mock.calls.Last, callInfo)
	mock.lockLast.Unlock()
	return mock.LastFunc(dest, conds...)
}

// LastCalls gets all the calls that were made to Last.
// Check the length with:
//
//	len(mockedDBer.LastCalls())
func (mock *DBerMock) LastCalls() []struct {
	Dest  interface{}
	Conds []interface{}
} {
	var calls []struct {
		Dest  interface{}
		Conds []interface{}
	}
	mock.lockLast.RLock()
	calls = mock.calls.Last
	mock.lockLast.RUnlock()
	return calls
}

// Limit calls LimitFunc.
func (mock *DBerMock) Limit(limit int) *gorm.DB {
	if mock.LimitFunc == nil {
		panic("DBerMock.LimitFunc: method is nil but DBer.Limit was just called")
	}
	callInfo := struct {
		Limit int
	}{
		Limit: limit,
	}
	mock.lockLimit.Lock()
	mock.calls.Limit = append(mock.calls.Limit, callInfo)
	mock.lockLimit.Unlock()
	return mock.LimitFunc(limit)
}

// LimitCalls gets all the calls that were made to Limit.
// Check the length with:
//
//	len(mockedDBer.LimitCalls())
func (mock *DBerMock) LimitCalls() []struct {
	Limit int
} {
	var calls []struct {
		Limit int
	}
	mock.lockLimit.RLock()
	calls = mock.calls.Limit
	mock.lockLimit.RUnlock()
	return calls
}

// Model calls ModelFunc.
func (mock *DBerMock) Model(value interface{}) *gorm.DB {
	if mock.ModelFunc == nil {
		panic("DBerMock.ModelFunc: method is nil but DBer.Model was just called")
	}
	callInfo := struct {
		Value interface{}
	}{
		Value: value,
	}
	mock.lockModel.Lock()
	mock.calls.Model = append(mock.calls.Model, callInfo)
	mock.lockModel.Unlock()
	return mock.ModelFunc(value)
}

// ModelCalls gets all the calls that were made to Model.
// Check the length with:
//
//	len(mockedDBer.ModelCalls())
func (mock *DBerMock) ModelCalls() []struct {
	Value interface{}
} {
	var calls []struct {
		Value interface{}
	}
	mock.lockModel.RLock()
	calls = mock.calls.Model
	mock.lockModel.RUnlock()
	return calls
}

// Not calls NotFunc.
func (mock *DBerMock) Not(query interface{}, args ...interface{}) *gorm.DB {
	if mock.NotFunc == nil {
		panic("DBerMock.NotFunc: method is nil but DBer.Not was just called")
	}
	callInfo := struct {
		Query interface{}
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	mock.lockNot.Lock()
	mock.calls.Not = append(mock.calls.Not, callInfo)
	mock.lockNot.Unlock()
	return mock.NotFunc(query, args...)
}

// NotCalls gets all the calls that were made to Not.
// Check the length with:
//
//	len(mockedDBer.NotCalls())
func (mock *DBerMock) NotCalls() []struct {
	Query interface{}
	Args  []interface{}
} {
	var calls []struct {
		Query interface{}
		Args  []interface{}
	}
	mock.lockNot.RLock()
	calls = mock.calls.Not
	mock.lockNot.RUnlock()
	return calls
}

// Offset calls OffsetFunc.
func (mock *DBerMock) Offset(offset int) *gorm.DB {
	if mock.OffsetFunc == nil {
		panic("DBerMock.OffsetFunc: method is nil but DBer.Offset was just called")
	}
	callInfo := struct {
		Offset int
	}{
		Offset: offset,
	}
	mock.lockOffset.Lock()
	mock.calls.Offset = append(mock.calls.Offset, callInfo)
	mock.lockOffset.Unlock()
	return mock.OffsetFunc(offset)
}

// OffsetCalls gets all the calls that were made to Offset.
// Check the length with:
//
//	len(mockedDBer.OffsetCalls())
func (mock *DBerMock) OffsetCalls() []struct {
	Offset int
} {
	var calls []struct {
		Offset int
	}
	mock.lockOffset.RLock()
	calls = mock.calls.Offset
	mock.lockOffset.RUnlock()
	return calls
}

// Omit calls OmitFunc.
func (mock *DBerMock) Omit(columns ...string) *gorm.DB {
	if mock.OmitFunc == nil {
		panic("DBerMock.OmitFunc: method is nil but DBer.Omit was just called")
	}
	callInfo := struct {
		Columns []string
	}{
		Columns: columns,
	}
	mock.lockOmit.Lock()
	mock.calls.Omit = append(mock.calls.Omit, callInfo)
	mock.lockOmit.Unlock()
	return mock.OmitFunc(columns...)
}

// OmitCalls gets all the calls that were made to Omit.
// Check the length with:
//
//	len(mockedDBer.OmitCalls())
func (mock *DBerMock) OmitCalls() []struct {
	Columns []string
} {
	var calls []struct {
		Columns []string
	}
	mock.lockOmit.RLock()
	calls = mock.calls.Omit
	mock.lockOmit.RUnlock()
	return calls
}

// Or calls OrFunc.
func (mock *DBerMock) Or(query interface{}, args ...interface{}) *gorm.DB {
	if mock.OrFunc == nil {
		panic("DBerMock.OrFunc: method is nil but DBer.Or was just called")
	}
	callInfo := struct {
		Query interface{}
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	mock.lockOr.Lock()
	mock.calls.Or = append(mock.calls.Or, callInfo)
	mock.lockOr.Unlock()
	return mock.OrFunc(query, args...)
}

// OrCalls gets all the calls that were made to Or.
// Check the length with:
//
//	len(mockedDBer.OrCalls())
func (mock *DBerMock) OrCalls() []struct {
	Query interface{}
	Args  []interface{}
} {
	var calls []struct {
		Query interface{}
		Args  []interface{}
	}
	mock.lockOr.RLock()
	calls = mock.calls.Or
	mock.lockOr.RUnlock()
	return calls
}

// Order calls OrderFunc.
func (mock *DBerMock) Order(value interface{}) *gorm.DB {
	if mock.OrderFunc == nil {
		panic("DBerMock.OrderFunc: method is nil but DBer.Order was just called")
	}
	callInfo := struct {
		Value interface{}
	}{
		Value: value,
	}
	mock.lockOrder.Lock()
	mock.calls.Order = append(mock.calls.Order, callInfo)
	mock.lockOrder.Unlock()
	return mock.OrderFunc(value)
}

// OrderCalls gets all the calls that were made to Order.
// Check the length with:
//
//	len(mockedDBer.OrderCalls())
func (mock *DBerMock) OrderCalls() []struct {
	Value interface{}
} {
	var calls []struct {
		Value interface{}
	}
	mock.lockOrder.RLock()
	calls = mock.calls.Order
	mock.lockOrder.RUnlock()
	return calls
}

// Pluck calls PluckFunc.
func (mock *DBerMock) Pluck(column string, dest interface{}) *gorm.DB {
	if mock.PluckFunc == nil {
		panic("DBerMock.PluckFunc: method is nil but DBer.Pluck was just called")
	}
	callInfo := struct {
		Column string
		Dest   interface{}
	}{
		Column: column,
		Dest:   dest,
	}
	mock.lockPluck.Lock()
	mock.calls.Pluck = append(mock.calls.Pluck, callInfo)
	mock.lockPluck.Unlock()
	return mock.PluckFunc(column, dest)
}

// PluckCalls gets all the calls that were made to Pluck.
// Check the length with:
//
//	len(mockedDBer.PluckCalls())
func (mock *DBerMock) PluckCalls() []struct {
	Column string
	Dest   interface{}
} {
	var calls []struct {
		Column string
		Dest   interface{}
	}
	mock.lockPluck.RLock()
	calls = mock.calls.Pluck
	mock.lockPluck.RUnlock()
	return calls
}

// Preload calls PreloadFunc.
func (mock *DBerMock) Preload(query string, args ...interface{}) *gorm.DB {
	if mock.PreloadFunc == nil {
		panic("DBerMock.PreloadFunc: method is nil but DBer.Preload was just called")
	}
	callInfo := struct {
		Query string
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	mock.lockPreload.Lock()
	mock.calls.Preload = append(mock.calls.Preload, callInfo)
	mock.lockPreload.Unlock()
	return mock.PreloadFunc(query, args...)
}

// PreloadCalls gets all the calls that were made to Preload.
// Check the length with:
//
//	len(mockedDBer.PreloadCalls())
func (mock *DBerMock) PreloadCalls() []struct {
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Query string
		Args  []interface{}
	}
	mock.lockPreload.RLock()
	calls = mock.calls.Preload
	mock.lockPreload.RUnlock()
	return calls
}

// Raw calls RawFunc.
func (mock *DBerMock) Raw(sqlMoqParam string, values ...interface{}) *gorm.DB {
	if mock.RawFunc == nil {
		panic("DBerMock.RawFunc: method is nil but DBer.Raw was just called")
	}
	callInfo := struct {
		SqlMoqParam string
		Values      []interface{}
	}{
		SqlMoqParam: sqlMoqParam,
		Values:      values,
	}
	mock.lockRaw.Lock()
	mock.calls.Raw = append(mock.calls.Raw, callInfo)
	mock.lockRaw.Unlock()
	return mock.RawFunc(sqlMoqParam, values...)
}

// RawCalls gets all the calls that were made to Raw.
// Check the length with:
//
//	len(mockedDBer.RawCalls())
func (mock *DBerMock) RawCalls() []struct {
	SqlMoqParam string
	Values      []interface{}
} {
	var calls []struct {
		SqlMoqParam string
		Values      []interface{}
	}
	mock.lockRaw.RLock()
	calls = mock.calls.Raw
	mock.lockRaw.RUnlock()
	return calls
}

// Rollback calls RollbackFunc.
func (mock *DBerMock) Rollback() *gorm.DB {
	if mock.RollbackFunc == nil {
		panic("DBerMock.RollbackFunc: method is nil but DBer.Rollback was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRollback.Lock()
	mock.calls.Rollback = append(mock.calls.Rollback, callInfo)
	mock.lockRollback.Unlock()
	return mock.RollbackFunc()
}

// RollbackCalls gets all the calls that were made to Rollback.
// Check the length with:
//
//	len(mockedDBer.RollbackCalls())
func (mock *DBerMock) RollbackCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRollback.RLock()
	calls = mock.calls.Rollback
	mock.lockRollback.RUnlock()
	return calls
}

// RollbackTo calls RollbackToFunc.
func (mock *DBerMock) RollbackTo(name string) *gorm.DB {
	if mock.RollbackToFunc == nil {
		panic("DBerMock.RollbackToFunc: method is nil but DBer.RollbackTo was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockRollbackTo.Lock()
	mock.calls.RollbackTo = append(mock.calls.RollbackTo, callInfo)
	mock.lockRollbackTo.Unlock()
	return mock.RollbackToFunc(name)
}

// RollbackToCalls gets all the calls that were made to RollbackTo.
// Check the length with:
//
//	len(mockedDBer.RollbackToCalls())
func (mock *DBerMock) RollbackToCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockRollbackTo.RLock()
	calls = mock.calls.RollbackTo
	mock.lockRollbackTo.RUnlock()
	return calls
}

// Row calls RowFunc.
func (mock *DBerMock) Row() *sql.Row {
	if mock.RowFunc == nil {
		panic("DBerMock.RowFunc: method is nil but DBer.Row was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRow.Lock()
	mock.calls.Row = append(mock.calls.Row, callInfo)
	mock.lockRow.Unlock()
	return mock.RowFunc()
}

// RowCalls gets all the calls that were made to Row.
// Check the length with:
//
//	len(mockedDBer.RowCalls())
func (mock *DBerMock) RowCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRow.RLock()
	calls = mock.calls.Row
	mock.lockRow.RUnlock()
	return calls
}

// Rows calls RowsFunc.
func (mock *DBerMock) Rows() (*sql.Rows, error) {
	if mock.RowsFunc == nil {
		panic("DBerMock.RowsFunc: method is nil but DBer.Rows was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRows.Lock()
	mock.calls.Rows = append(mock.calls.Rows, callInfo)
	mock.lockRows.Unlock()
	return mock.RowsFunc()
}

// RowsCalls gets all the calls that were made to Rows.
// Check the length with:
//
//	len(mockedDBer.RowsCalls())
func (mock *DBerMock) RowsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRows.RLock()
	calls = mock.calls.Rows
	mock.lockRows.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *DBerMock) Save(value interface{}) *gorm.DB {
	if mock.SaveFunc == nil {
		panic("DBerMock.SaveFunc: method is nil but DBer.Save was just called")
	}
	callInfo := struct {
		Value interface{}
	}{
		Value: value,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(value)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedDBer.SaveCalls())
func (mock *DBerMock) SaveCalls() []struct {
	Value interface{}
} {
	var calls []struct {
		Value interface{}
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// SavePoint calls SavePointFunc.
func (mock *DBerMock) SavePoint(name string) *gorm.DB {
	if mock.SavePointFunc == nil {
		panic("DBerMock.SavePointFunc: method is nil but DBer.SavePoint was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockSavePoint.Lock()
	mock.calls.SavePoint = append(mock.calls.SavePoint, callInfo)
	mock.lockSavePoint.Unlock()
	return mock.SavePointFunc(name)
}

// SavePointCalls gets all the calls that were made to SavePoint.
// Check the length with:
//
//	len(mockedDBer.SavePointCalls())
func (mock *DBerMock) SavePointCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockSavePoint.RLock()
	calls = mock.calls.SavePoint
	mock.lockSavePoint.RUnlock()
	return calls
}

// Scan calls ScanFunc.
func (mock *DBerMock) Scan(dest interface{}) *gorm.DB {
	if mock.ScanFunc == nil {
		panic("DBerMock.ScanFunc: method is nil but DBer.Scan was just called")
	}
	callInfo := struct {
		Dest interface{}
	}{
		Dest: dest,
	}
	mock.lockScan.Lock()
	mock.calls.Scan = append(mock.calls.Scan, callInfo)
	mock.lockScan.Unlock()
	return mock.ScanFunc(dest)
}

// ScanCalls gets all the calls that were made to Scan.
// Check the length with:
//
//	len(mockedDBer.ScanCalls())
func (mock *DBerMock) ScanCalls() []struct {
	Dest interface{}
} {
	var calls []struct {
		Dest interface{}
	}
	mock.lockScan.RLock()
	calls = mock.calls.Scan
	mock.lockScan.RUnlock()
	return calls
}

// ScanRows calls ScanRowsFunc.
func (mock *DBerMock) ScanRows(rows *sql.Rows, dest interface{}) error {
	if mock.ScanRowsFunc == nil {
		panic("DBerMock.ScanRowsFunc: method is nil but DBer.ScanRows was just called")
	}
	callInfo := struct {
		Rows *sql.Rows
		Dest interface{}
	}{
		Rows: rows,
		Dest: dest,
	}
	mock.lockScanRows.Lock()
	mock.calls.ScanRows = append(mock.calls.ScanRows, callInfo)
	mock.lockScanRows.Unlock()
	return mock.ScanRowsFunc(rows, dest)
}

// ScanRowsCalls gets all the calls that were made to ScanRows.
// Check the length with:
//
//	len(mockedDBer.ScanRowsCalls())
func (mock *DBerMock) ScanRowsCalls() []struct {
	Rows *sql.Rows
	Dest interface{}
} {
	var calls []struct {
		Rows *sql.Rows
		Dest interface{}
	}
	mock.lockScanRows.RLock()
	calls = mock.calls.ScanRows
	mock.lockScanRows.RUnlock()
	return calls
}

// Scopes calls ScopesFunc.
func (mock *DBerMock) Scopes(funcs ...func(*gorm.DB) *gorm.DB) *gorm.DB {
	if mock.ScopesFunc == nil {
		panic("DBerMock.ScopesFunc: method is nil but DBer.Scopes was just called")
	}
	callInfo := struct {
		Funcs []func(*gorm.DB) *gorm.DB
	}{
		Funcs: funcs,
	}
	mock.lockScopes.Lock()
	mock.calls.Scopes = append(mock.calls.Scopes, callInfo)
	mock.lockScopes.Unlock()
	return mock.ScopesFunc(funcs...)
}

// ScopesCalls gets all the calls that were made to Scopes.
// Check the length with:
//
//	len(mockedDBer.ScopesCalls())
func (mock *DBerMock) ScopesCalls() []struct {
	Funcs []func(*gorm.DB) *gorm.DB
} {
	var calls []struct {
		Funcs []func(*gorm.DB) *gorm.DB
	}
	mock.lockScopes.RLock()
	calls = mock.calls.Scopes
	mock.lockScopes.RUnlock()
	return calls
}

// Select calls SelectFunc.
func (mock *DBerMock) Select(query interface{}, args ...interface{}) *gorm.DB {
	if mock.SelectFunc == nil {
		panic("DBerMock.SelectFunc: method is nil but DBer.Select was just called")
	}
	callInfo := struct {
		Query interface{}
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	mock.lockSelect.Lock()
	mock.calls.Select = append(mock.calls.Select, callInfo)
	mock.lockSelect.Unlock()
	return mock.SelectFunc(query, args...)
}

// SelectCalls gets all the calls that were made to Select.
// Check the length with:
//
//	len(mockedDBer.SelectCalls())
func (mock *DBerMock) SelectCalls() []struct {
	Query interface{}
	Args  []interface{}
} {
	var calls []struct {
		Query interface{}
		Args  []interface{}
	}
	mock.lockSelect.RLock()
	calls = mock.calls.Select
	mock.lockSelect.RUnlock()
	return calls
}

// Table calls TableFunc.
func (mock *DBerMock) Table(name string, args ...interface{}) *gorm.DB {
	if mock.TableFunc == nil {
		panic("DBerMock.TableFunc: method is nil but DBer.Table was just called")
	}
	callInfo := struct {
		Name string
		Args []interface{}
	}{
		Name: name,
		Args: args,
	}
	mock.lockTable.Lock()
	mock.calls.Table = append(mock.calls.Table, callInfo)
	mock.lockTable.Unlock()
	return mock.TableFunc(name, args...)
}

// TableCalls gets all the calls that were made to Table.
// Check the length with:
//
//	len(mockedDBer.TableCalls())
func (mock *DBerMock) TableCalls() []struct {
	Name string
	Args []interface{}
} {
	var calls []struct {
		Name string
		Args []interface{}
	}
	mock.lockTable.RLock()
	calls = mock.calls.Table
	mock.lockTable.RUnlock()
	return calls
}

// Take calls TakeFunc.
func (mock *DBerMock) Take(dest interface{}, conds ...interface{}) *gorm.DB {
	if mock.TakeFunc == nil {
		panic("DBerMock.TakeFunc: method is nil but DBer.Take was just called")
	}
	callInfo := struct {
		Dest  interface{}
		Conds []interface{}
	}{
		Dest:  dest,
		Conds: conds,
	}
	mock.lockTake.Lock()
	mock.calls.Take = append(mock.calls.Take, callInfo)
	mock.lockTake.Unlock()
	return mock.TakeFunc(dest, conds...)
}

// TakeCalls gets all the calls that were made to Take.
// Check the length with:
//
//	len(mockedDBer.TakeCalls())
func (mock *DBerMock) TakeCalls() []struct {
	Dest  interface{}
	Conds []interface{}
} {
	var calls []struct {
		Dest  interface{}
		Conds []interface{}
	}
	mock.lockTake.RLock()
	calls = mock.calls.Take
	mock.lockTake.RUnlock()
	return calls
}

// Transaction calls TransactionFunc.
func (mock *DBerMock) Transaction(fc func(tx *gorm.DB) error, opts ...*sql.TxOptions) error {
	if mock.TransactionFunc == nil {
		panic("DBerMock.TransactionFunc: method is nil but DBer.Transaction was just called")
	}
	callInfo := struct {
		Fc   func(tx *gorm.DB) error
		Opts []*sql.TxOptions
	}{
		Fc:   fc,
		Opts: opts,
	}
	mock.lockTransaction.Lock()
	mock.calls.Transaction = append(mock.calls.Transaction, callInfo)
	mock.lockTransaction.Unlock()
	return mock.TransactionFunc(fc, opts...)
}

// TransactionCalls gets all the calls that were made to Transaction.
// Check the length with:
//
//	len(mockedDBer.TransactionCalls())
func (mock *DBerMock) TransactionCalls() []struct {
	Fc   func(tx *gorm.DB) error
	Opts []*sql.TxOptions
} {
	var calls []struct {
		Fc   func(tx *gorm.DB) error
		Opts []*sql.TxOptions
	}
	mock.lockTransaction.RLock()
	calls = mock.calls.Transaction
	mock.lockTransaction.RUnlock()
	return calls
}

// Unscoped calls UnscopedFunc.
func (mock *DBerMock) Unscoped() *gorm.DB {
	if mock.UnscopedFunc == nil {
		panic("DBerMock.UnscopedFunc: method is nil but DBer.Unscoped was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUnscoped.Lock()
	mock.calls.Unscoped = append(mock.calls.Unscoped, callInfo)
	mock.lockUnscoped.Unlock()
	return mock.UnscopedFunc()
}

// UnscopedCalls gets all the calls that were made to Unscoped.
// Check the length with:
//
//	len(mockedDBer.UnscopedCalls())
func (mock *DBerMock) UnscopedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUnscoped.RLock()
	calls = mock.calls.Unscoped
	mock.lockUnscoped.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *DBerMock) Update(column string, value interface{}) *gorm.DB {
	if mock.UpdateFunc == nil {
		panic("DBerMock.UpdateFunc: method is nil but DBer.Update was just called")
	}
	callInfo := struct {
		Column string
		Value  interface{}
	}{
		Column: column,
		Value:  value,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(column, value)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedDBer.UpdateCalls())
func (mock *DBerMock) UpdateCalls() []struct {
	Column string
	Value  interface{}
} {
	var calls []struct {
		Column string
		Value  interface{}
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// UpdateColumn calls UpdateColumnFunc.
func (mock *DBerMock) UpdateColumn(column string, value interface{}) *gorm.DB {
	if mock.UpdateColumnFunc == nil {
		panic("DBerMock.UpdateColumnFunc: method is nil but DBer.UpdateColumn was just called")
	}
	callInfo := struct {
		Column string
		Value  interface{}
	}{
		Column: column,
		Value:  value,
	}
	mock.lockUpdateColumn.Lock()
	mock.calls.UpdateColumn = append(mock.calls.UpdateColumn, callInfo)
	mock.lockUpdateColumn.Unlock()
	return mock.UpdateColumnFunc(column, value)
}

// UpdateColumnCalls gets all the calls that were made to UpdateColumn.
// Check the length with:
//
//	len(mockedDBer.UpdateColumnCalls())
func (mock *DBerMock) UpdateColumnCalls() []struct {
	Column string
	Value  interface{}
} {
	var calls []struct {
		Column string
		Value  interface{}
	}
	mock.lockUpdateColumn.RLock()
	calls = mock.calls.UpdateColumn
	mock.lockUpdateColumn.RUnlock()
	return calls
}

// UpdateColumns calls UpdateColumnsFunc.
func (mock *DBerMock) UpdateColumns(values interface{}) *gorm.DB {
	if mock.UpdateColumnsFunc == nil {
		panic("DBerMock.UpdateColumnsFunc: method is nil but DBer.UpdateColumns was just called")
	}
	callInfo := struct {
		Values interface{}
	}{
		Values: values,
	}
	mock.lockUpdateColumns.Lock()
	mock.calls.UpdateColumns = append(mock.calls.UpdateColumns, callInfo)
	mock.lockUpdateColumns.Unlock()
	return mock.UpdateColumnsFunc(values)
}

// UpdateColumnsCalls gets all the calls that were made to UpdateColumns.
// Check the length with:
//
//	len(mockedDBer.UpdateColumnsCalls())
func (mock *DBerMock) UpdateColumnsCalls() []struct {
	Values interface{}
} {
	var calls []struct {
		Values interface{}
	}
	mock.lockUpdateColumns.RLock()
	calls = mock.calls.UpdateColumns
	mock.lockUpdateColumns.RUnlock()
	return calls
}

// Updates calls UpdatesFunc.
func (mock *DBerMock) Updates(values interface{}) *gorm.DB {
	if mock.UpdatesFunc == nil {
		panic("DBerMock.UpdatesFunc: method is nil but DBer.Updates was just called")
	}
	callInfo := struct {
		Values interface{}
	}{
		Values: values,
	}
	mock.lockUpdates.Lock()
	mock.calls.Updates = append(mock.calls.Updates, callInfo)
	mock.lockUpdates.Unlock()
	return mock.UpdatesFunc(values)
}

// UpdatesCalls gets all the calls that were made to Updates.
// Check the length with:
//
//	len(mockedDBer.UpdatesCalls())
func (mock *DBerMock) UpdatesCalls() []struct {
	Values interface{}
} {
	var calls []struct {
		Values interface{}
	}
	mock.lockUpdates.RLock()
	calls = mock.calls.Updates
	mock.lockUpdates.RUnlock()
	return calls
}

// Where calls WhereFunc.
func (mock *DBerMock) Where(query interface{}, args ...interface{}) *gorm.DB {
	if mock.WhereFunc == nil {
		panic("DBerMock.WhereFunc: method is nil but DBer.Where was just called")
	}
	callInfo := struct {
		Query interface{}
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	mock.lockWhere.Lock()
	mock.calls.Where = append(mock.calls.Where, callInfo)
	mock.lockWhere.Unlock()
	return mock.WhereFunc(query, args...)
}

// WhereCalls gets all the calls that were made to Where.
// Check the length with:
//
//	len(mockedDBer.WhereCalls())
func (mock *DBerMock) WhereCalls() []struct {
	Query interface{}
	Args  []interface{}
} {
	var calls []struct {
		Query interface{}
		Args  []interface{}
	}
	mock.lockWhere.RLock()
	calls = mock.calls.Where
	mock.lockWhere.RUnlock()
	return calls
}
